use amp_core::parquet::ParkingRestriction;

#[derive(Clone, Debug, PartialEq)]
pub enum MatchResult {
    Valid(ParkingRestriction),
    Invalid,
}

/// Match user input address against static correlations from server
///
/// This checks if the provided address (gata, gatunummer, postnummer) exists
/// in the pre-computed correlations generated by:
/// `cargo run --release correlate -c 20 -a kdtree`
///
/// # Arguments
/// * `gata` - Street name (e.g., "Storgatan")
/// * `gatunummer` - Street number (e.g., "10")
/// * `postnummer` - Postal code (e.g., "22100")
///
/// # Returns
/// MatchResult::Valid with address data if found, MatchResult::Invalid otherwise

pub fn match_address(
    gata: &str,
    gatunummer: &str,
    postnummer: &str,
    data: &std::collections::HashMap<String, ParkingRestriction>,
) -> MatchResult {
    let key = format!("{} {}-{}", gata.trim(), gatunummer.trim(), postnummer.trim());

    match data.get(&key) {
        Some(restriction) => MatchResult::Valid(restriction.clone()),
        None => MatchResult::Invalid,
    }
}

/// Validate address input fields
///
/// Checks that all fields contain non-empty values
pub fn validate_input(gata: &str, gatunummer: &str, postnummer: &str) -> bool {
    !gata.trim().is_empty() && !gatunummer.trim().is_empty() && !postnummer.trim().is_empty()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_input() {
        assert!(validate_input("Storgatan", "10", "22100"));
        assert!(!validate_input("", "10", "22100"));
        assert!(!validate_input("Storgatan", "", "22100"));
        assert!(!validate_input("Storgatan", "10", ""));
    }

    #[test]
    fn test_match_address() {
        // This will return Invalid for now since static_data needs to be populated
        //let result = match_address("NonExistent", "999", "00000", None);
        //assert_eq!(result, MatchResult::Invalid);
    }
}
