//! Address matching against parking restriction database
//!
//! Provides functions to validate and match user-provided addresses
//! against the pre-computed correlations from the amp server.
//!
//! # Overview
//! This module uses the new `DB` struct with proper timestamp handling.
//! It provides fast address lookup and validation for parking restrictions.
//!
//! # Examples
//! ```no_run
//! use amp_android::matching::{match_address, MatchResult};
//!
//! match match_address("Storgatan", "10", "22100") {
//!     MatchResult::Valid(entry) => {
//!         println!("Found restriction: {}", entry.adress);
//!         // Use entry.start_time and entry.end_time for time calculations
//!     }
//!     MatchResult::Invalid => println!("Address not found"),
//! }
//! ```
use crate::static_data::{get_address_data, get_static_data};
use amp_core::structs::DB;
use std::collections::HashMap;
/// Result of address matching operation
///
/// Represents whether an address was found in the parking restriction database.
#[derive(Debug, Clone)]
pub enum MatchResult {
    /// Address found in database with full details
    ///
    /// Contains a `DB` struct with parking restriction information including
    /// timestamps, address details, and parking zone information.
    Valid(Box<DB>),
    /// Address not found or invalid
    ///
    /// Returned when:
    /// - Address doesn't exist in the database
    /// - Input validation failed
    /// - Data format was invalid
    Invalid,
}
impl MatchResult {
    /// Check if the result is valid
    ///
    /// # Returns
    /// true if Valid variant, false if Invalid
    ///
    /// # Examples
    /// ```no_run
    /// use amp_android::matching::{match_address, MatchResult};
    ///
    /// let result = match_address("Storgatan", "10", "22100");
    /// if result.is_valid() {
    ///     println!("Address found!");
    /// }
    /// ```
    pub fn is_valid(&self) -> bool {
        matches!(self, MatchResult::Valid(_))
    }
    /// Check if the result is invalid
    ///
    /// # Returns
    /// true if Invalid variant, false if Valid
    pub fn is_invalid(&self) -> bool {
        matches!(self, MatchResult::Invalid)
    }
    /// Get the DB entry if valid
    ///
    /// # Returns
    /// Some(&DB) if Valid, None if Invalid
    ///
    /// # Examples
    /// ```no_run
    /// use amp_android::matching::match_address;
    ///
    /// let result = match_address("Storgatan", "10", "22100");
    /// if let Some(db) = result.as_ref() {
    ///     println!("Address: {}", db.adress);
    /// }
    /// ```
    pub fn as_ref(&self) -> Option<&DB> {
        match self {
            MatchResult::Valid(db) => Some(db),
            MatchResult::Invalid => None,
        }
    }
    /// Consume the result and get the DB entry if valid
    ///
    /// # Returns
    /// Some(DB) if Valid, None if Invalid
    pub fn into_inner(self) -> Option<DB> {
        match self {
            MatchResult::Valid(db) => Some(*db),
            MatchResult::Invalid => None,
        }
    }
}
/// Get parking restriction data
///
/// Returns a reference to the parking data HashMap with address keys
/// mapping to DB entries containing parking restriction information.
///
/// # Returns
/// Static reference to parking data using DB struct
///
/// # Examples
/// ```no_run
/// use amp_android::matching::get_parking_data;
///
/// let data = get_parking_data();
/// println!("Loaded {} parking entries", data.len());
/// ```
pub fn get_parking_data() -> &'static HashMap<String, DB> {
    get_static_data()
}
/// Match user input address against static correlations from server
///
/// This checks if the provided address (street, street_number, postal_code) exists
/// in the pre-computed correlations generated by:
/// `cargo run --release -- output --android`
///
/// The function performs:
/// 1. Input validation (non-empty fields)
/// 2. Key generation (format: "street_number_postalcode")
/// 3. Database lookup
///
/// # Arguments
/// * `street` - Street name (e.g., "Storgatan")
/// * `street_number` - Street number (e.g., "10")
/// * `postal_code` - Postal code (e.g., "22100")
///
/// # Returns
/// * `MatchResult::Valid(DB)` - Address found with parking restriction data
/// * `MatchResult::Invalid` - Address not found or invalid input
///
/// # Examples
/// ```no_run
/// use amp_android::matching::{match_address, MatchResult};
/// use chrono::Utc;
///
/// match match_address("Storgatan", "10", "22100") {
///     MatchResult::Valid(entry) => {
///         println!("Found: {}", entry.adress);
///         let now = Utc::now();
///         if entry.is_active(now) {
///             println!("Restriction is currently active!");
///         }
///     }
///     MatchResult::Invalid => {
///         println!("Address not found in database");
///     }
/// }
/// ```
///
/// # Performance
/// This is an O(1) HashMap lookup operation.
pub fn match_address(street: &str, street_number: &str, postal_code: &str) -> MatchResult {
    if !validate_input(street, street_number, postal_code) {
        eprintln!("[Matching] Invalid input: empty field(s)");
        return MatchResult::Invalid;
    }
    match get_address_data(street, street_number, postal_code) {
        Some(entry) => {
            eprintln!(
                "[Matching] Found address: {} {} {}",
                street, street_number, postal_code,
            );
            MatchResult::Valid(Box::from(entry.clone()))
        }
        None => {
            eprintln!(
                "[Matching] Address not found: {} {} {}",
                street, street_number, postal_code,
            );
            MatchResult::Invalid
        }
    }
}
/// Match address with fuzzy logic (case-insensitive, trimmed)
///
/// More lenient version of `match_address` that:
/// - Trims whitespace from all inputs
/// - Converts to lowercase for comparison
/// - Handles common variations
///
/// # Arguments
/// * `street` - Street name (case-insensitive)
/// * `street_number` - Street number
/// * `postal_code` - Postal code
///
/// # Returns
/// MatchResult with found entry or Invalid
///
/// # Examples
/// ```no_run
/// use amp_android::matching::match_address_fuzzy;
///
/// // These all work:
/// let r1 = match_address_fuzzy("STORGATAN", "10", "22100");
/// let r2 = match_address_fuzzy(" storgatan ", " 10 ", " 22100 ");
/// let r3 = match_address_fuzzy("Storgatan", "10", "22100");
/// ```
pub fn match_address_fuzzy(street: &str, street_number: &str, postal_code: &str) -> MatchResult {
    let street_norm = street.trim().to_lowercase();
    let number_norm = street_number.trim();
    let postal_norm = postal_code.trim();
    if !validate_input(&street_norm, number_norm, postal_norm) {
        return MatchResult::Invalid;
    }
    let data = get_static_data();
    for (_, entry) in data.iter() {
        let entry_street = entry
            .gata
            .as_ref()
            .map(|s| s.to_lowercase())
            .unwrap_or_default();
        let entry_number = entry.gatunummer.as_deref().unwrap_or("");
        let entry_postal = entry.postnummer.as_deref().unwrap_or("");
        if entry_street == street_norm && entry_number == number_norm && entry_postal == postal_norm
        {
            eprintln!("[Matching] Fuzzy match found: {}", entry.adress);
            return MatchResult::Valid(Box::from(entry.clone()));
        }
    }
    eprintln!(
        "[Matching] No fuzzy match for: {} {} {}",
        street, street_number, postal_code,
    );
    MatchResult::Invalid
}
/// Validate address input fields
///
/// Checks that all fields contain non-empty values after trimming whitespace.
/// This is a basic validation - the actual address existence is checked by
/// `match_address`.
///
/// # Arguments
/// * `street` - Street name
/// * `street_number` - Street number
/// * `postal_code` - Postal code
///
/// # Returns
/// true if all fields are non-empty after trimming, false otherwise
///
/// # Examples
/// ```
/// use amp_android::matching::validate_input;
///
/// assert!(validate_input("Storgatan", "10", "22100"));
/// assert!(validate_input(" Storgatan ", " 10 ", " 22100 "));  // Trimmed
/// assert!(!validate_input("", "10", "22100"));  // Empty street
/// assert!(!validate_input("Storgatan", "", "22100"));  // Empty number
/// assert!(!validate_input("  ", "10", "22100"));  // Whitespace only
/// ```
pub fn validate_input(street: &str, street_number: &str, postal_code: &str) -> bool {
    !street.trim().is_empty() && !street_number.trim().is_empty() && !postal_code.trim().is_empty()
}
/// Search for addresses matching a partial street name
///
/// Returns all addresses where the street name contains the search term.
/// Case-insensitive search.
///
/// # Arguments
/// * `partial_street` - Partial street name to search for
///
/// # Returns
/// Vector of DB entries matching the search
///
/// # Examples
/// ```no_run
/// use amp_android::matching::search_by_street;
///
/// // Find all addresses on streets containing "stor"
/// let results = search_by_street("stor");
/// for db in results {
///     println!("Found: {}", db.adress);
/// }
/// ```
pub fn search_by_street(partial_street: &str) -> Vec<DB> {
    let search_term = partial_street.trim().to_lowercase();
    if search_term.is_empty() {
        return Vec::new();
    }
    get_static_data()
        .values()
        .filter(|db| {
            db.gata
                .as_ref()
                .map(|gata| gata.to_lowercase().contains(&search_term))
                .unwrap_or(false)
        })
        .cloned()
        .collect()
}
/// Get all addresses in a specific postal code
///
/// Convenience wrapper around `static_data::get_addresses_in_postal_code`
/// that returns owned DB entries instead of references.
///
/// # Arguments
/// * `postal_code` - Postal code to filter by
///
/// # Returns
/// Vector of DB entries in the postal code
///
/// # Examples
/// ```no_run
/// use amp_android::matching::get_addresses_in_area;
///
/// let addresses = get_addresses_in_area("22100");
/// println!("Found {} addresses in 22100", addresses.len());
/// ```
pub fn get_addresses_in_area(postal_code: &str) -> Vec<DB> {
    use crate::static_data::get_addresses_in_postal_code;
    get_addresses_in_postal_code(postal_code)
        .into_iter()
        .cloned()
        .collect()
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_validate_input() {
        assert!(validate_input("Storgatan", "10", "22100"));
        assert!(!validate_input("", "10", "22100"));
        assert!(!validate_input("Storgatan", "", "22100"));
        assert!(!validate_input("Storgatan", "10", ""));
        assert!(!validate_input("  ", "10", "22100"));
    }
    #[test]
    fn test_validate_input_whitespace() {
        assert!(validate_input(" Storgatan ", " 10 ", " 22100 "));
    }
    #[test]
    fn test_match_result_is_valid() {
        let valid = MatchResult::Valid(Box::from(
            DB::from_dag_tid(
                Some("22100".to_string()),
                "Test".to_string(),
                None,
                None,
                None,
                15,
                "0800-1200",
                None,
                None,
                None,
                2024,
                1,
            )
            .unwrap(),
        ));
        assert!(valid.is_valid());
        assert!(!valid.is_invalid());
        let invalid = MatchResult::Invalid;
        assert!(invalid.is_invalid());
        assert!(!invalid.is_valid());
    }
    #[test]
    fn test_match_result_as_ref() {
        let db = DB::from_dag_tid(
            Some("22100".to_string()),
            "Test Street 10".to_string(),
            Some("Test Street".to_string()),
            Some("10".to_string()),
            None,
            15,
            "0800-1200",
            None,
            None,
            None,
            2024,
            1,
        )
        .unwrap();
        let valid = MatchResult::Valid(Box::from(db.clone()));
        assert!(valid.as_ref().is_some());
        assert_eq!(valid.as_ref().unwrap().adress, "Test Street 10");
        let invalid = MatchResult::Invalid;
        assert!(invalid.as_ref().is_none());
    }
    #[test]
    fn test_match_result_into_inner() {
        let db = DB::from_dag_tid(
            Some("22100".to_string()),
            "Test".to_string(),
            None,
            None,
            None,
            15,
            "0800-1200",
            None,
            None,
            None,
            2024,
            1,
        )
        .unwrap();
        let valid = MatchResult::Valid(Box::from(db));
        let inner = valid.into_inner();
        assert!(inner.is_some());
        let invalid = MatchResult::Invalid;
        assert!(invalid.into_inner().is_none());
    }
    #[test]
    fn test_search_by_street_empty() {
        let results = search_by_street("");
        assert_eq!(results.len(), 0);
        let results = search_by_street("  ");
        assert_eq!(results.len(), 0);
    }
}
