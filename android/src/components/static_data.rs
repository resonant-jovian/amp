//! Static parking restriction database
//!
//! This module provides access to the pre-computed parking restriction data
//! from the amp server. The data is embedded at compile time using `include_bytes!`
//! and loaded once into a static HashMap.
//!
//! # Data Format
//! The data comes from the correlations generated by:
//! ```bash
//! cargo run --release -- output --android
//! ```
//!
//! This creates a parquet file with parking restriction records using the new
//! `DB` struct with proper timestamp handling.
//!
//! # Examples
//! ```no_run
//! use amp_android::static_data::{get_static_data, get_address_data};
//!
//! // Get all parking data
//! let data = get_static_data();
//! println!("Loaded {} parking entries", data.len());
//!
//! // Look up specific address
//! if let Some(entry) = get_address_data("Storgatan", "10", "22100") {
//!     println!("Found restriction: {}", entry.adress);
//! }
//! ```
use amp_core::structs::DB;
use bytes::Bytes;
use chrono::{Datelike, NaiveDate};
use std::collections::HashMap;
use std::sync::OnceLock;
/// Static storage for the parking database
///
/// Loaded once at first access using OnceLock for thread-safe initialization.
static PARKING_DATA: OnceLock<HashMap<String, DB>> = OnceLock::new();
/// The embedded parquet file bytes
///
/// This is the correlations file generated by:
/// `cargo run --release -- output --android`
const PARQUET_BYTES: &[u8] = include_bytes!("../../assets/data/db.parquet");
/// Determine the best year/month to use for a given day
///
/// Strategy:
/// 1. If the date is valid in current month and hasn't passed yet, use current month
/// 2. If the date has already passed this month, use next month
/// 3. If the date is invalid in current month (e.g., Feb 30), use next month
///
/// # Arguments
/// * `day` - Day of month (1-31)
/// * `current_year` - Current year
/// * `current_month` - Current month (1-12)
/// * `current_day` - Current day of month
///
/// # Returns
/// Tuple of (year, month) to use for creating the DB entry
fn determine_year_month(day: u8, current_year: i32, current_month: u32, current_day: u32) -> (i32, u32) {
    // Check if date is valid in current month
    let current_month_valid = NaiveDate::from_ymd_opt(current_year, current_month, day as u32).is_some();
    
    // If valid in current month and hasn't passed yet, use current month
    if current_month_valid && (day as u32) >= current_day {
        return (current_year, current_month);
    }
    
    // Otherwise, use next month
    let mut next_month = current_month + 1;
    let mut next_year = current_year;
    if next_month > 12 {
        next_month = 1;
        next_year += 1;
    }
    
    // Verify the date is valid in next month, otherwise it's truly invalid
    if NaiveDate::from_ymd_opt(next_year, next_month, day as u32).is_some() {
        (next_year, next_month)
    } else {
        // Date is invalid in both months (shouldn't happen for normal dates)
        // Fall back to current month and let DB::from_dag_tid handle it
        (current_year, current_month)
    }
}
/// Load parquet data from embedded bytes
///
/// Uses `amp_core::parquet::read_parquet` to deserialize the DB records.
/// Called once at first access.
///
/// # Returns
/// HashMap mapping address keys (format: "postnummer_street_number_day") to DB entries
///
/// # Panics
/// If the parquet file is corrupted or cannot be parsed
fn load_parking_data() -> HashMap<String, DB> {
    eprintln!("[StaticData] Loading parking data from embedded parquet...");
    match read_db_parquet_from_bytes(PARQUET_BYTES) {
        Ok(records) => {
            let mut map = HashMap::new();
            let now = chrono::Utc::now();
            let current_year = now.year();
            let current_month = now.month();
            let current_day = now.day();
            
            eprintln!("[StaticData] Current date: {}-{:02}-{:02}", current_year, current_month, current_day);
            
            for record in records {
                let Some(dag) = record.dag else {
                    eprintln!("[StaticData] Skipping record without dag field");
                    continue;
                };
                let Some(ref tid) = record.tid else {
                    eprintln!("[StaticData] Skipping record without tid field");
                    continue;
                };
                
                // Determine best year/month for this day
                let (year, month) = determine_year_month(dag, current_year, current_month, current_day);
                
                if let Some(db) = DB::from_dag_tid(
                    record.postnummer.clone(),
                    record.adress.clone(),
                    Some(record.gata.clone()),
                    Some(record.gatunummer.clone()),
                    record.info.clone(),
                    dag,
                    tid,
                    record.taxa.clone(),
                    record.antal_platser,
                    record.typ_av_parkering.clone(),
                    year,
                    month,
                ) {
                    let key = format!(
                        "{}_{}_{}_{}",
                        record.postnummer.as_deref().unwrap_or("unknown"),
                        record.gata.to_lowercase(),
                        record.gatunummer,
                        dag,
                    );
                    map.insert(key, db);
                } else {
                    eprintln!(
                        "[StaticData] Failed to create DB from record: {} {} {} (day {}, tried {}-{:02})",
                        record.gata, record.gatunummer, dag, dag, year, month
                    );
                }
            }
            eprintln!(
                "[StaticData] Loaded {} parking restriction entries",
                map.len()
            );
            map
        }
        Err(e) => {
            eprintln!("[StaticData] FATAL: Failed to load parking data: {}", e);
            panic!("Failed to load embedded parking data: {}", e);
        }
    }
}
/// Helper function to read parquet from bytes
///
/// This wraps the core read_db_parquet function to work with embedded bytes
/// Uses the Bytes type which implements ChunkReader trait required by parquet
fn read_db_parquet_from_bytes(bytes: &[u8]) -> anyhow::Result<Vec<amp_core::structs::OutputData>> {
    use arrow::array::Array;
    use parquet::arrow::arrow_reader::ParquetRecordBatchReaderBuilder;
    let bytes_obj = Bytes::copy_from_slice(bytes);
    let builder = ParquetRecordBatchReaderBuilder::try_new(bytes_obj)
        .map_err(|e| anyhow::anyhow!("Failed to create Parquet reader builder: {}", e))?;
    let reader = builder
        .build()
        .map_err(|e| anyhow::anyhow!("Failed to build Parquet record batch reader: {}", e))?;
    let mut result = Vec::new();
    for batch_result in reader {
        let batch: arrow::record_batch::RecordBatch =
            batch_result.map_err(|e| anyhow::anyhow!("Failed to read batch: {}", e))?;
        let get_string_column = |name: &str| -> anyhow::Result<&arrow::array::StringArray> {
            batch
                .column(batch.schema().index_of(name)?)
                .as_any()
                .downcast_ref::<arrow::array::StringArray>()
                .ok_or_else(|| anyhow::anyhow!("{} column missing or wrong type", name))
        };
        let get_u8_column = |name: &str| -> anyhow::Result<&arrow::array::UInt8Array> {
            batch
                .column(batch.schema().index_of(name)?)
                .as_any()
                .downcast_ref::<arrow::array::UInt8Array>()
                .ok_or_else(|| anyhow::anyhow!("{} column missing or wrong type", name))
        };
        let get_u64_column = |name: &str| -> anyhow::Result<&arrow::array::UInt64Array> {
            batch
                .column(batch.schema().index_of(name)?)
                .as_any()
                .downcast_ref::<arrow::array::UInt64Array>()
                .ok_or_else(|| anyhow::anyhow!("{} column missing or wrong type", name))
        };
        let postnummer = get_string_column("postnummer")?;
        let adress = get_string_column("adress")?;
        let gata = get_string_column("gata")?;
        let gatunummer = get_string_column("gatunummer")?;
        let info = get_string_column("info")?;
        let tid = get_string_column("tid")?;
        let dag = get_u8_column("dag")?;
        let taxa = get_string_column("taxa")?;
        let antal_platser = get_u64_column("antal_platser")?;
        let typ_av_parkering = get_string_column("typ_av_parkering")?;
        for i in 0..batch.num_rows() {
            let get_optional_string =
                |arr: &arrow::array::StringArray, idx: usize| -> Option<String> {
                    if arr.is_null(idx) {
                        None
                    } else {
                        Some(arr.value(idx).to_string())
                    }
                };
            let get_required_string = |arr: &arrow::array::StringArray, idx: usize| -> String {
                if arr.is_null(idx) {
                    String::new()
                } else {
                    arr.value(idx).to_string()
                }
            };
            let get_optional_u8 = |arr: &arrow::array::UInt8Array, idx: usize| -> Option<u8> {
                if arr.is_null(idx) {
                    None
                } else {
                    Some(arr.value(idx))
                }
            };
            let get_optional_u64 = |arr: &arrow::array::UInt64Array, idx: usize| -> Option<u64> {
                if arr.is_null(idx) {
                    None
                } else {
                    Some(arr.value(idx))
                }
            };
            let entry = amp_core::structs::OutputData {
                postnummer: get_optional_string(postnummer, i),
                adress: get_required_string(adress, i),
                gata: get_required_string(gata, i),
                gatunummer: get_required_string(gatunummer, i),
                info: get_optional_string(info, i),
                tid: get_optional_string(tid, i),
                dag: get_optional_u8(dag, i),
                taxa: get_optional_string(taxa, i),
                antal_platser: get_optional_u64(antal_platser, i),
                typ_av_parkering: get_optional_string(typ_av_parkering, i),
            };
            result.push(entry);
        }
    }
    Ok(result)
}
/// Get reference to the static parking data
///
/// First call will load and parse the embedded parquet file.
/// Subsequent calls return the cached data.
///
/// # Returns
/// Reference to HashMap mapping address keys to DB entries
///
/// # Thread Safety
/// Thread-safe initialization using `OnceLock`
///
/// # Examples
/// ```no_run
/// use amp_android::static_data::get_static_data;
///
/// let data = get_static_data();
/// println!("Total parking entries: {}", data.len());
///
/// for (key, entry) in data.iter().take(5) {
///     println!("  {}: {}", key, entry.adress);
/// }
/// ```
pub fn get_static_data() -> &'static HashMap<String, DB> {
    PARKING_DATA.get_or_init(load_parking_data)
}
/// Look up parking restriction by address components
///
/// Convenience function to search by street, street_number, and postal_code.
/// Generates the lookup key and searches the static data.
///
/// # Arguments
/// * `street` - Street name (e.g., "Storgatan")
/// * `street_number` - Street number (e.g., "10")
/// * `postal_code` - Postal code (e.g., "22100")
///
/// # Returns
/// Some(&DB) if address found, None otherwise
///
/// # Examples
/// ```no_run
/// use amp_android::static_data::get_address_data;
/// use chrono::Utc;
///
/// if let Some(entry) = get_address_data("Storgatan", "10", "22100") {
///     println!("Found: {}", entry.adress);
///     let now = Utc::now();
///     if entry.is_active(now) {
///         println!("Restriction is currently active!");
///     }
/// }
/// ```
pub fn get_address_data<'a>(
    street: &str,
    street_number: &str,
    postal_code: &str,
) -> Option<&'a DB> {
    let data = get_static_data();
    for day in 1..=31 {
        let key = format!(
            "{}_{}_{}_{}",
            postal_code,
            street.to_lowercase(),
            street_number,
            day,
        );
        if let Some(entry) = data.get(&key) {
            return Some(entry);
        }
    }
    None
}
/// Get all addresses in a specific postal code
///
/// Returns all parking restrictions within the given postal code.
///
/// # Arguments
/// * `postal_code` - Postal code to filter by (e.g., "22100")
///
/// # Returns
/// Vector of references to DB entries in the postal code
///
/// # Examples
/// ```no_run
/// use amp_android::static_data::get_addresses_in_postal_code;
///
/// let addresses = get_addresses_in_postal_code("22100");
/// println!("Found {} addresses in 22100", addresses.len());
/// for addr in addresses.iter().take(10) {
///     println!("  {}", addr.adress);
/// }
/// ```
pub fn get_addresses_in_postal_code(postal_code: &str) -> Vec<&DB> {
    let data = get_static_data();
    data.values()
        .filter(|db| {
            db.postnummer
                .as_ref()
                .map(|p| p == postal_code)
                .unwrap_or(false)
        })
        .collect()
}
/// Get all unique postal codes in the database
///
/// Useful for generating picker lists or filtering UI.
///
/// # Returns
/// Sorted vector of unique postal codes
///
/// # Examples
/// ```no_run
/// use amp_android::static_data::get_all_postal_codes;
///
/// let codes = get_all_postal_codes();
/// println!("Database covers {} postal codes", codes.len());
/// for code in codes.iter().take(5) {
///     println!("  {}", code);
/// }
/// ```
pub fn get_all_postal_codes() -> Vec<String> {
    let data = get_static_data();
    let mut codes: Vec<String> = data
        .values()
        .filter_map(|db| db.postnummer.clone())
        .collect();
    codes.sort();
    codes.dedup();
    codes
}
/// Count total number of parking restrictions in database
///
/// # Returns
/// Total number of DB entries
///
/// # Examples
/// ```no_run
/// use amp_android::static_data::count_entries;
///
/// let total = count_entries();
/// println!("Database contains {} parking restrictions", total);
/// ```
pub fn count_entries() -> usize {
    get_static_data().len()
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_load_static_data() {
        let data = get_static_data();
        assert!(
            !data.is_empty(),
            "Parking data should not be empty after loading"
        );
        eprintln!("Loaded {} entries for testing", data.len());
    }
    #[test]
    fn test_get_all_postal_codes() {
        let codes = get_all_postal_codes();
        assert!(!codes.is_empty(), "Should have at least one postal code");
        for i in 1..codes.len() {
            assert!(codes[i - 1] <= codes[i], "Postal codes should be sorted");
        }
    }
    #[test]
    fn test_count_entries() {
        let count = count_entries();
        assert!(count > 0, "Should have at least one entry");
        let data = get_static_data();
        assert_eq!(count, data.len(), "Count should match data length");
    }
    #[test]
    fn test_get_addresses_in_postal_code() {
        let codes = get_all_postal_codes();
        if let Some(first_code) = codes.first() {
            let addresses = get_addresses_in_postal_code(first_code);
            assert!(
                !addresses.is_empty(),
                "Should find addresses in first postal code"
            );
            for addr in addresses {
                assert_eq!(
                    addr.postnummer.as_deref().unwrap(),
                    first_code,
                    "All addresses should be in requested postal code",
                );
            }
        }
    }
    #[test]
    fn test_determine_year_month_future_date() {
        // Test with a future date in current month
        let (year, month) = determine_year_month(25, 2026, 2, 5);
        assert_eq!(year, 2026);
        assert_eq!(month, 2);
    }
    #[test]
    fn test_determine_year_month_past_date() {
        // Test with a past date in current month (should use next month)
        let (year, month) = determine_year_month(3, 2026, 2, 5);
        assert_eq!(year, 2026);
        assert_eq!(month, 3);
    }
    #[test]
    fn test_determine_year_month_invalid_date() {
        // Test with Feb 30 (should use next month where it's valid)
        let (year, month) = determine_year_month(30, 2026, 2, 5);
        assert_eq!(year, 2026);
        assert_eq!(month, 3);
    }
    #[test]
    fn test_determine_year_month_feb_29_non_leap() {
        // Test with Feb 29 in non-leap year (should use next month)
        let (year, month) = determine_year_month(29, 2026, 2, 5);
        assert_eq!(year, 2026);
        assert_eq!(month, 3);
    }
}
